from typing import Any, Dict, Optional

from .base import BaseTool


class VulnerabilitySearcher(BaseTool):
    async def execute(self, package_name: str, version: Optional[str] = None, ecosystem: Optional[str] = None) -> Dict[str, Any]:
        try:
            import json
            import urllib.request
            import urllib.error

            eco = ecosystem or "Go"  # default to Go modules
            payload = {
                "package": {"name": package_name, "ecosystem": eco},
            }
            if version and version not in ("latest", ""):  # OSV expects semver like v1.2.3 for Go
                payload["version"] = version

            # Query OSV API
            url = "https://api.osv.dev/v1/query"
            data = json.dumps(payload).encode("utf-8")
            req = urllib.request.Request(url, data=data, headers={"Content-Type": "application/json"}, method="POST")
            results: list[dict[str, Any]] = []
            try:
                with urllib.request.urlopen(req, timeout=10) as resp:
                    body = resp.read().decode("utf-8")
                    obj = json.loads(body)
                    vulns = obj.get("vulns", []) or []
                    for v in vulns:
                        results.append({
                            "id": v.get("id"),
                            "summary": v.get("summary"),
                            "severity": v.get("severity"),
                            "aliases": v.get("aliases", []),
                            "affected": v.get("affected", []),
                            "references": v.get("references", []),
                        })
            except (urllib.error.URLError, urllib.error.HTTPError, TimeoutError) as e:
                # Graceful fallback with note
                return self.format_success({
                    "package": package_name,
                    "version": version or "latest",
                    "ecosystem": eco,
                    "results": [],
                    "error": f"OSV查询失败: {e}",
                })

            # Optional semantic indexing of results using txtai
            semantic_enabled = False
            semantic_matches: list[dict[str, Any]] = []
            try:
                from code_audit_mcp.ai.semantic import SemanticIndexer
                texts = []
                for r in results:
                    texts.append((r.get("summary") or "") + "\n" + json.dumps(r, ensure_ascii=False))
                indexer = SemanticIndexer()
                semantic_enabled = indexer.build(texts)
                if semantic_enabled:
                    q = f"{package_name} {eco} security vulnerability"
                    for score, idx in indexer.search(q, 5):
                        r = results[idx]
                        semantic_matches.append({"id": r.get("id"), "score": float(score), "summary": r.get("summary")})
            except Exception:
                semantic_enabled = False

            return self.format_success({
                "package": package_name,
                "version": version or "latest",
                "ecosystem": eco,
                "results": results,
                "semantic_enabled": semantic_enabled,
                "semantic_top_matches": semantic_matches,
            })
        except Exception as e:
            return self.format_error(e)