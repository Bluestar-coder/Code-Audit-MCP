#!/usr/bin/env python3
"""
æ¼æ´æ£€æµ‹åŠŸèƒ½æµ‹è¯•è„šæœ¬
"""

import grpc
import sys
import os
import tempfile

# æ·»åŠ protoç›®å½•åˆ°è·¯å¾„
sys.path.append(os.path.join(os.path.dirname(__file__), 'proto'))

import ast_parser_pb2 as pb
import ast_parser_pb2_grpc as pb_grpc

def create_test_files():
    """åˆ›å»ºæµ‹è¯•ç”¨çš„æ¼æ´ä»£ç æ–‡ä»¶"""
    test_files = {}
    
    # SQLæ³¨å…¥æ¼æ´ç¤ºä¾‹
    sql_injection_code = '''
function getUserData(userId) {
    const query = "SELECT * FROM users WHERE id = " + userId;
    return db.query(query);
}

function searchUsers(name) {
    const sql = `SELECT * FROM users WHERE name = '${name}'`;
    return database.execute(sql);
}
'''
    
    # XSSæ¼æ´ç¤ºä¾‹
    xss_code = '''
function displayMessage(userInput) {
    document.getElementById("content").innerHTML = userInput;
}

function renderTemplate(data) {
    return "<div>" + data.message + "</div>";
}
'''
    
    # è·¯å¾„éå†æ¼æ´ç¤ºä¾‹
    path_traversal_code = '''
const fs = require('fs');

function readFile(filename) {
    const filePath = "./uploads/" + filename;
    return fs.readFileSync(filePath);
}

function downloadFile(path) {
    return fs.createReadStream(path);
}
'''
    
    # å®‰å…¨ä»£ç ç¤ºä¾‹
    safe_code = '''
function getUserData(userId) {
    const query = "SELECT * FROM users WHERE id = ?";
    return db.query(query, [userId]);
}

function displayMessage(userInput) {
    document.getElementById("content").textContent = userInput;
}

function readFile(filename) {
    const safePath = path.resolve("./uploads", filename);
    if (!safePath.startsWith(path.resolve("./uploads"))) {
        throw new Error("Invalid file path");
    }
    return fs.readFileSync(safePath);
}
'''
    
    # åˆ›å»ºä¸´æ—¶æ–‡ä»¶
    with tempfile.NamedTemporaryFile(mode='w', suffix='.js', delete=False) as f:
        f.write(sql_injection_code)
        test_files['sql_injection.js'] = f.name
    
    with tempfile.NamedTemporaryFile(mode='w', suffix='.js', delete=False) as f:
        f.write(xss_code)
        test_files['xss.js'] = f.name
    
    with tempfile.NamedTemporaryFile(mode='w', suffix='.js', delete=False) as f:
        f.write(path_traversal_code)
        test_files['path_traversal.js'] = f.name
    
    with tempfile.NamedTemporaryFile(mode='w', suffix='.js', delete=False) as f:
        f.write(safe_code)
        test_files['safe.js'] = f.name
    
    return test_files

def test_single_file_scan(stub, file_path, file_type):
    """æµ‹è¯•å•ä¸ªæ–‡ä»¶æ‰«æ"""
    print(f"\nğŸ” æ‰«ææ–‡ä»¶: {file_type}")
    print(f"   è·¯å¾„: {file_path}")
    
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()
        
        request = pb.ScanFileRequest(
            file_path=file_path,
            content=content,
            language="javascript"
        )
        
        response = stub.ScanFile(request)
        
        print(f"   âœ… æ‰«æå®Œæˆ")
        print(f"   ğŸ“Š å‘ç° {len(response.findings)} ä¸ªæ½œåœ¨æ¼æ´")
        
        for i, finding in enumerate(response.findings, 1):
            print(f"   ğŸš¨ æ¼æ´ {i}:")
            print(f"      ç±»å‹: {finding.rule_id}")
            print(f"      ä¸¥é‡ç¨‹åº¦: {finding.severity}")
            print(f"      è¡Œå·: {finding.line}")
            print(f"      æè¿°: {finding.message}")
            print(f"      ä»£ç : {finding.code}")
        
        if len(response.findings) == 0:
            print(f"   âœ… æœªå‘ç°æ¼æ´")
        
        return response
        
    except Exception as e:
        print(f"   âŒ æ‰«æå¤±è´¥: {e}")
        return None

def test_batch_scan(stub, test_files):
    """æµ‹è¯•æ‰¹é‡æ–‡ä»¶æ‰«æ"""
    print(f"\nğŸ“¦ æ‰¹é‡æ‰«ææµ‹è¯•")
    
    try:
        scan_requests = []
        for file_type, file_path in test_files.items():
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            scan_requests.append(pb.ScanFileRequest(
                file_path=file_path,
                content=content,
                language="javascript"
            ))
        
        request = pb.ScanBatchRequest(files=scan_requests)
        response = stub.ScanBatch(request)
        
        print(f"   âœ… æ‰¹é‡æ‰«æå®Œæˆ")
        print(f"   ğŸ“ æ‰«æäº† {len(response.results)} ä¸ªæ–‡ä»¶")
        
        # ç»Ÿè®¡æ‰€æœ‰å‘ç°çš„æ¼æ´
        total_findings = 0
        severity_counts = {}
        
        for result in response.results:
            if result.success:
                total_findings += len(result.findings)
                for finding in result.findings:
                    severity = finding.severity
                    severity_counts[severity] = severity_counts.get(severity, 0) + 1
        
        print(f"   ğŸ“Š æ€»è®¡å‘ç° {total_findings} ä¸ªæ½œåœ¨æ¼æ´")
        
        if severity_counts:
            print(f"   ğŸ“ˆ æŒ‰ä¸¥é‡ç¨‹åº¦ç»Ÿè®¡:")
            for severity, count in severity_counts.items():
                print(f"      {severity}: {count} ä¸ª")
        
        if response.overall_statistics:
            print(f"   ğŸ“ˆ æ€»ä½“ç»Ÿè®¡: {response.overall_statistics}")
        
        return response
        
    except Exception as e:
        print(f"   âŒ æ‰¹é‡æ‰«æå¤±è´¥: {e}")
        return None

def test_get_rules(stub):
    """æµ‹è¯•è·å–è§„åˆ™åˆ—è¡¨"""
    print(f"\nğŸ“‹ è·å–æ¼æ´æ£€æµ‹è§„åˆ™")
    
    try:
        request = pb.GetRulesRequest()
        response = stub.GetRules(request)
        
        print(f"   âœ… è·å–æˆåŠŸ")
        print(f"   ğŸ“Š å…±æœ‰ {len(response.rules)} ä¸ªè§„åˆ™")
        
        for i, rule in enumerate(response.rules, 1):
            print(f"   ğŸ“ è§„åˆ™ {i}:")
            print(f"      ID: {rule.id}")
            print(f"      åç§°: {rule.name}")
            print(f"      ç±»å‹: {rule.category}")
            print(f"      ä¸¥é‡ç¨‹åº¦: {rule.severity}")
            print(f"      æè¿°: {rule.description}")
            print(f"      æ”¯æŒè¯­è¨€: {', '.join(rule.language)}")
            print(f"      æ£€æµ‹æ¨¡å¼æ•°é‡: {len(rule.patterns)}")
        
        return response
        
    except Exception as e:
        print(f"   âŒ è·å–è§„åˆ™å¤±è´¥: {e}")
        import traceback
        traceback.print_exc()
        return None

def cleanup_test_files(test_files):
    """æ¸…ç†æµ‹è¯•æ–‡ä»¶"""
    for file_path in test_files.values():
        try:
            os.unlink(file_path)
        except:
            pass

def main():
    print("ğŸ”’ ä»£ç æ¼æ´æ£€æµ‹åŠŸèƒ½æµ‹è¯•")
    print("=" * 50)
    
    # è¿æ¥åˆ°gRPCæœåŠ¡å™¨
    try:
        channel = grpc.insecure_channel('localhost:50051')
        stub = pb_grpc.VulnerabilityDetectorStub(channel)
        print("âœ… å·²è¿æ¥åˆ°gRPCæœåŠ¡å™¨")
    except Exception as e:
        print(f"âŒ è¿æ¥æœåŠ¡å™¨å¤±è´¥: {e}")
        return
    
    # åˆ›å»ºæµ‹è¯•æ–‡ä»¶
    test_files = create_test_files()
    print(f"ğŸ“ åˆ›å»ºäº† {len(test_files)} ä¸ªæµ‹è¯•æ–‡ä»¶")
    
    try:
        # æµ‹è¯•è·å–è§„åˆ™
        test_get_rules(stub)
        
        # æµ‹è¯•å•ä¸ªæ–‡ä»¶æ‰«æ
        for file_type, file_path in test_files.items():
            test_single_file_scan(stub, file_path, file_type)
        
        # æµ‹è¯•æ‰¹é‡æ‰«æ
        test_batch_scan(stub, test_files)
        
        print(f"\nğŸ‰ æ‰€æœ‰æµ‹è¯•å®Œæˆ!")
        
    finally:
        # æ¸…ç†æµ‹è¯•æ–‡ä»¶
        cleanup_test_files(test_files)
        print(f"ğŸ§¹ å·²æ¸…ç†æµ‹è¯•æ–‡ä»¶")

if __name__ == "__main__":
    main()